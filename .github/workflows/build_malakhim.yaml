name: Build Malakhim release zip

on:
  workflow_dispatch:
    inputs:
      prerelease:
        description: "Publish as prerelease?"
        type: boolean
        default: true
      draft:
        description: "Create as draft?"
        type: boolean
        default: false
      make_latest:
        description: "Mark as latest?"
        type: boolean
        default: false

permissions:
  contents: write

jobs:
  zip:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure tools (zip, jq, rsync)
        shell: bash
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y zip jq rsync

      # Find the .toc (any folder / any case), read version, and derive addon name/dir
      - name: Detect addon (.toc) and version
        id: detect
        shell: bash
        run: |
          set -e

          # Find the first *.toc anywhere (prefer top-level or matching repo name)
          TOC_PATH="$( \
            { [ -f "Malakhim.toc" ] && echo "Malakhim.toc"; } \
            || { [ -f "Malakhim.TOC" ] && echo "Malakhim.TOC"; } \
            || { [ -f "Malakhim.toc" ] && echo "Malakhim.toc"; } \
            || { [ -f "Malakhim.TOC" ] && echo "Malakhim.TOC"; } \
            || find . -maxdepth 2 -type f -iname "*.toc" | head -n1 \
          )"

          if [ -z "$TOC_PATH" ]; then
            echo "No .toc found. Failing early."
            exit 1
          fi

          # Normalize dir/name
          ADDON_DIR="$(dirname "$TOC_PATH")"
          [ "$ADDON_DIR" = "." ] && ADDON_DIR=""
          ADDON_FILE="$(basename "$TOC_PATH")"
          ADDON_NAME="${ADDON_FILE%.*}"

          # Version (case-insensitive key)
          VER="$(awk 'BEGIN{IGNORECASE=1} /^##[[:space:]]*Version[[:space:]]*:/ {sub(/^[^:]*:[[:space:]]*/,""); print; exit}' "$TOC_PATH")"
          [ -z "$VER" ] && VER="0.0.0"
          VER="$(printf '%s' "$VER" | tr -cd '0-9A-Za-z._-')"

          echo "Found TOC: $TOC_PATH"
          echo "Addon name: $ADDON_NAME"
          echo "Version:    $VER"
          echo "Source dir: ${ADDON_DIR:-.}"

          {
            echo "TOC_PATH=$TOC_PATH"
            echo "ADDON_NAME=$ADDON_NAME"
            echo "ADDON_DIR=$ADDON_DIR"
            echo "ADDON_VER=$VER"
          } >> "$GITHUB_ENV"

      - name: Stage addon files
        shell: bash
        run: |
          set -e
          : "${ADDON_NAME:?missing}"
          : "${TOC_PATH:?missing}"
          # If ADDON_DIR is empty, use repo root
          SRC="${ADDON_DIR:-.}"
          STAGE="dist/${ADDON_NAME}"

          rm -rf dist
          mkdir -p "$STAGE"

          # Stage only addon-relevant files from the detected source dir
          rsync -av --prune-empty-dirs \
            --include="${ADDON_NAME}.toc" --include="${ADDON_NAME}.TOC" \
            --include='*.lua' --include='*.xml' \
            --include='*.blp' --include='*.tga' --include='*.dds' --include='*.mdx' \
            --include='*.mp3' --include='*.ogg' --include='*.wav' \
            --include='README.md' \
            --include='Media/**' --include='Locales/**' --include='Textures/**' --include='Icons/**' --include='Images/**' \
            --include='Fonts/**' --include='Sound/**' --include='Libs/**' --include='Modules/**' \
            --include='*/' \
            --exclude='*' \
            "$SRC"/ "$STAGE/"

          echo "Staged contents:"
          find dist -maxdepth 3 -type f -print

          # Verify the .toc exists in the staged folder
          if ! ls "$STAGE"/"${ADDON_NAME}".[Tt][Oo][Cc] >/dev/null 2>&1; then
            echo "ERROR: ${ADDON_NAME}.toc not found in $STAGE"
            ls -l "$STAGE" || true
            exit 1
          fi

      - name: Compose release notes (from VERSION if present)
        shell: bash
        run: |
          set -e
          mkdir -p dist

          TITLE="${ADDON_NAME} v${ADDON_VER}"
          DATE_UTC="$(date -u +%Y-%m-%d)"
          PREV_TAG="$(git describe --tags --abbrev=0 --match 'v*' 2>/dev/null || true)"

          LABEL=""; SUMMARY=""; FEATURES=""; FIXES=""; CHANGES=""
          KNOWN=""; COMPAT=""; THANKS=""

          if [ -f VERSION ]; then
            LABEL="$(jq -r '.label // empty' VERSION || true)"
            SUMMARY="$(jq -r '.summary // .notes // empty' VERSION || true)"
            FEATURES="$(jq -r 'if (.features // empty)=="" then "" else (.features|if type=="array" then map("- "+.)|join("\n") else "- "+tostring(.) end) end' VERSION || true)"
            FIXES="$(jq -r 'if (.fixes // empty)=="" then "" else (.fixes   |if type=="array" then map("- "+.)|join("\n") else "- "+tostring(.) end) end' VERSION || true)"
            CHANGES="$(jq -r 'if (.changes // empty)=="" then "" else (.changes|if type=="array" then map("- "+.)|join("\n") else "- "+tostring(.) end) end' VERSION || true)"
            KNOWN="$(jq -r 'if (.known_issues // empty)=="" then "" else (.known_issues|if type=="array" then map("- "+.)|join("\n") else "- "+tostring(.) end) end' VERSION || true)"
            COMPAT="$(jq -r 'if (.compat // empty)=="" then "" else (.compat|if type=="array" then map("- "+.)|join("\n") else "- "+tostring(.) end) end' VERSION || true)"
            THANKS="$(jq -r 'if (.thanks // empty)=="" then "" else (.thanks|if type=="array" then map("- "+.)|join("\n") else "- "+tostring(.) end) end' VERSION || true)"
          fi

          COMMITS=""
          if [ -z "$FEATURES$FIXES$CHANGES" ] && [ -n "$PREV_TAG" ]; then
            COMMITS="$(git log --pretty='- %s (%h)' "${PREV_TAG}..HEAD" || true)"
          fi

          if [ -n "$LABEL" ]; then RELEASE_NAME="${TITLE} (${LABEL})"; else RELEASE_NAME="${TITLE}"; fi
          echo "RELEASE_NAME=$RELEASE_NAME" >> "$GITHUB_ENV"

          {
            echo "# ${RELEASE_NAME}"
            echo
            echo "_Build date:_ ${DATE_UTC}"
            echo
            [ -n "$SUMMARY" ] && { echo "$SUMMARY"; echo; }
            [ -n "$FEATURES" ] && { echo "## Features"; echo "$FEATURES"; echo; }
            [ -n "$FIXES" ]    && { echo "## Fixes";    echo "$FIXES";    echo; }
            [ -n "$CHANGES" ]  && { echo "## Changes";  echo "$CHANGES";  echo; }
            [ -n "$COMMITS" ]  && { echo "## Commits since ${PREV_TAG}"; echo "$COMMITS"; echo; }
            echo "## Compatibility"
            if [ -n "$COMPAT" ]; then
              echo "$COMPAT"
            else
              echo "- Epoch (WotLK 3.3.5a / Interface 30300)"
              echo "- Lua 5.1"
            fi
            echo
            echo "## Installation"
            echo "1. Download the zip attached below."
            echo "2. Unzip so the folder **${ADDON_NAME}/** sits in your \`Interface/AddOns/\` directory."
            echo "3. Restart the client or type \`/reload\`."
            [ -n "$KNOWN" ] && { echo; echo "## Known Issues"; echo "$KNOWN"; }
            [ -n "$THANKS" ] && { echo; echo "## Thanks"; echo "$THANKS"; }
          } > dist/RELEASE_NOTES.md

          echo "---- RELEASE_NOTES.md ----"
          sed -n '1,200p' dist/RELEASE_NOTES.md

      - name: Add notes/VERSION into addon folder (optional)
        shell: bash
        run: |
          set -e
          cp dist/RELEASE_NOTES.md "dist/${ADDON_NAME}/RELEASE_NOTES.txt"
          [ -f VERSION ] && cp VERSION "dist/${ADDON_NAME}/VERSION.json" || true

      - name: Package zip
        shell: bash
        run: |
          set -e
          ZIP="${ADDON_NAME}-v${ADDON_VER}-release.zip"
          ( cd dist && zip -r9 "../$ZIP" "${ADDON_NAME}" )
          ls -l "$ZIP"
          echo "ZIP_NAME=$ZIP" >> "$GITHUB_ENV"

      - name: Upload artifact (Actions)
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.ADDON_NAME }}-v${{ env.ADDON_VER }}-release
          path: ${{ env.ZIP_NAME }}

      - name: Create GitHub Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.ADDON_VER }}
          name: ${{ env.RELEASE_NAME }}
          body_path: dist/RELEASE_NOTES.md
          draft: ${{ inputs.draft }}
          prerelease: ${{ inputs.prerelease }}
          make_latest: ${{ inputs.make_latest }}
          files: |
            ${{ env.ZIP_NAME }}
            dist/RELEASE_NOTES.md
